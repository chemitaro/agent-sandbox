#!/bin/bash
#
# Generate .env file for Sandbox Project
# This script is self-contained and uses relative paths from its location
#

set -e

# Get script directory and project root
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Fixed paths relative to project root
CONFIG_FILE="$PROJECT_ROOT/sandbox.config"
ENV_FILE="$PROJECT_ROOT/.env"
EXAMPLE_FILE="$PROJECT_ROOT/sandbox.config.example"

# Local agent config root (git-ignored). These dirs are bind-mounted into the container.
AGENT_HOME_DIR="$PROJECT_ROOT/.agent-home"

# Ensure local agent config directories exist before compose starts.
ensure_agent_home_dirs() {
    mkdir -p \
        "$AGENT_HOME_DIR/.claude" \
        "$AGENT_HOME_DIR/.codex" \
        "$AGENT_HOME_DIR/.gemini" \
        "$AGENT_HOME_DIR/.cache/uv" \
        "$AGENT_HOME_DIR/.cache/pre-commit" \
        "$AGENT_HOME_DIR/commandhistory"
}

# Detect timezone
detect_timezone() {
    if [ -n "$TZ" ]; then
        echo "$TZ"
    elif [ -L /etc/localtime ]; then
        readlink /etc/localtime | sed 's|.*/zoneinfo/||'
    elif [ -f /etc/timezone ]; then
        cat /etc/timezone
    elif command -v timedatectl >/dev/null 2>&1; then
        timedatectl | grep "Time zone" | awk '{print $3}'
    else
        echo "Asia/Tokyo"
    fi
}

# Detect git root (fallback to project root if not in git repo)
detect_git_root() {
    git -C "$PROJECT_ROOT" rev-parse --show-toplevel 2>/dev/null || echo "$PROJECT_ROOT"
}

# Convert full path to short form using ~
convert_to_short_path() {
    local full_path="$1"
    local home_path="$HOME"
    
    # Replace home directory path with ~
    if [[ "$full_path" == "$home_path"* ]]; then
        echo "${full_path/#$home_path/~}"
    else
        echo "$full_path"
    fi
}

# Generate Docker-compliant container name from path
generate_container_name() {
    local source_path="$1"
    
    # First, convert to short path using existing function
    local short_path=$(convert_to_short_path "$source_path")
    
    # Remove leading ~/ if present
    local clean_path=$(echo "$short_path" | sed 's|^~/||')
    
    # Replace all slashes with hyphens
    local container_name=$(echo "$clean_path" | tr '/' '-')
    
    # Keep only valid Docker container name characters
    container_name=$(echo "$container_name" | tr -cd 'a-zA-Z0-9._-')
    
    # Remove leading non-alphanumeric characters
    container_name=$(echo "$container_name" | sed 's/^[^a-zA-Z0-9]*//')
    
    # Handle empty or number-starting names
    if [ -z "$container_name" ] || [[ "$container_name" =~ ^[0-9] ]]; then
        container_name="sandbox-${container_name}"
    fi
    
    # No prefix needed - the path itself is descriptive enough
    
    # Limit length for Docker constraints (max 63 chars)
    if [ ${#container_name} -gt 63 ]; then
        container_name="${container_name:0:63}"
    fi
    
    echo "$container_name"
}

# Main generation function
generate_env_file() {
    echo "üîß Generating .env file..."
    
    # Check if config file exists
    if [ ! -f "$CONFIG_FILE" ]; then
        echo "‚ùå Error: $CONFIG_FILE not found!"
        echo "üìù Please create it from sandbox.config.example:"
        echo "   cp $EXAMPLE_FILE $CONFIG_FILE"
        exit 1
    fi
    
    # Get system values
    local detected_tz=$(detect_timezone)
    local git_root=$(detect_git_root)
    local current_user=$(whoami)
    
    # Start generating .env file
    cat > "$ENV_FILE" << EOF
# Auto-generated by scripts/generate-env.sh - DO NOT EDIT
# Generated at: $(date)

# User Configuration
EOF
    
    # Extract all environment variables from config (excluding comments, empty lines, and PRODUCT_NAME)
    # PRODUCT_NAME will be handled separately to add PRODUCT_WORK_DIR
    grep -E '^[[:space:]]*[A-Z_][A-Z0-9_]*[[:space:]]*=' "$CONFIG_FILE" | \
        grep -v '^[[:space:]]*PRODUCT_NAME[[:space:]]*=' | \
        sed 's/[[:space:]]*=[[:space:]]*/=/' >> "$ENV_FILE" || true
    
    # Add TZ if not already set
    if ! grep -q "^TZ=" "$ENV_FILE"; then
        echo "TZ=$detected_tz" >> "$ENV_FILE"
    fi
    
    # Add auto-detected values
    cat >> "$ENV_FILE" << EOF

# Auto-detected Values
HOST_SANDBOX_PATH=$git_root
HOST_USERNAME=$current_user
EOF
    
    # Extract SOURCE_PATH and set HOST_PRODUCT_PATH
    local source_path=$(grep -E '^[[:space:]]*SOURCE_PATH[[:space:]]*=' "$CONFIG_FILE" | \
        sed 's/^[^=]*=//' | xargs)
    if [ -n "$source_path" ]; then
        echo "HOST_PRODUCT_PATH=$source_path" >> "$ENV_FILE"
        
        # Extract PRODUCT_NAME
        local product_name=$(grep -E '^[[:space:]]*PRODUCT_NAME[[:space:]]*=' "$CONFIG_FILE" | \
            sed 's/^[^=]*=//' | xargs)
        if [ -n "$product_name" ]; then
            echo "PRODUCT_NAME=$product_name" >> "$ENV_FILE"
            echo "PRODUCT_WORK_DIR=/srv/$product_name" >> "$ENV_FILE"
        fi
        
        # Generate CONTAINER_NAME from SOURCE_PATH and PRODUCT_NAME
        local container_name=$(generate_container_name "$source_path")
        # If product name exists and is not default, append it to container name
        if [ -n "$product_name" ] && [ "$product_name" != "product" ]; then
            container_name="${container_name}-${product_name}"
        fi
        echo "CONTAINER_NAME=$container_name" >> "$ENV_FILE"
    fi
    
    echo "" >> "$ENV_FILE"
    echo "‚úÖ .env file generated successfully!"
}


# Generate devcontainer.json from template

# Generate Git read-only override compose file
generate_git_overrides() {
    local overrides_file="$PROJECT_ROOT/docker-compose.git-ro.yml"
    local source_path=$(grep "^SOURCE_PATH=" "$ENV_FILE" | cut -d'=' -f2)
    local product_work_dir=$(grep "^PRODUCT_WORK_DIR=" "$ENV_FILE" | cut -d'=' -f2)

    if [ -z "$source_path" ]; then
        echo "‚ö†Ô∏è  Warning: SOURCE_PATH not set; writing empty Git override"
        cat > "$overrides_file" <<'YAML'
version: "3.8"
services:
  agent-sandbox:
    volumes: []
YAML
        return
    fi

    if [ -z "$product_work_dir" ]; then
        product_work_dir="/srv/product"
    fi

    if [ ! -x "$PROJECT_ROOT/scripts/generate-git-ro-overrides.sh" ]; then
        echo "‚ö†Ô∏è  Warning: Git override script not executable; writing empty override"
        cat > "$overrides_file" <<'YAML'
version: "3.8"
services:
  agent-sandbox:
    volumes: []
YAML
        return
    fi

    $PROJECT_ROOT/scripts/generate-git-ro-overrides.sh "$source_path" "$product_work_dir" "$overrides_file"
}

generate_devcontainer() {
    local template_file="$PROJECT_ROOT/.devcontainer/devcontainer-template.json"
    local output_file="$PROJECT_ROOT/.devcontainer/devcontainer.json"
    
    # Check if template exists
    if [ ! -f "$template_file" ]; then
        echo "‚ö†Ô∏è  Warning: devcontainer template not found, skipping devcontainer generation"
        return
    fi
    
    # Get PRODUCT_WORK_DIR from .env
    local product_work_dir=$(grep "^PRODUCT_WORK_DIR=" "$ENV_FILE" | cut -d'=' -f2)
    
    if [ -z "$product_work_dir" ]; then
        echo "‚ö†Ô∏è  Warning: PRODUCT_WORK_DIR not found in .env, using default /srv/product"
        product_work_dir="/srv/product"
    fi
    
    # Replace placeholder with actual value
    sed "s|{{PRODUCT_WORK_DIR}}|$product_work_dir|g" "$template_file" > "$output_file"
    
    echo "‚úÖ devcontainer.json generated with workspaceFolder: $product_work_dir"
}

# Validate the generated configuration
validate_config() {
    echo "üîç Validating configuration..."
    
    if ! grep -q "^SOURCE_PATH=.." "$ENV_FILE"; then
        echo "‚ùå Error: Source path is not set in $CONFIG_FILE"
        echo "   This is a required setting."
        exit 1
    fi
    
    local source_path=$(grep "^SOURCE_PATH=" "$ENV_FILE" | cut -d'=' -f2)
    if [ ! -d "$source_path" ]; then
        echo "‚ö†Ô∏è  Warning: Source path '$source_path' does not exist"
        echo "   Container will start but the directory will be empty"
    fi
    
    if ! grep -q "^GH_TOKEN=.." "$ENV_FILE"; then
        echo "‚ÑπÔ∏è  Note: GitHub token is not set"
        echo "   Some features may be limited"
    fi
    
    echo "‚úÖ Configuration is valid!"
}

# Main execution
main() {
    ensure_agent_home_dirs
    generate_env_file
    generate_devcontainer
    # Git metadata is writable by default (no read-only .git overrides).
    
    # Validate if requested (check for --validate argument)
    if [ "$1" = "--validate" ]; then
        validate_config
    fi
}

# Run main function
main "$@"
