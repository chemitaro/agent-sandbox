#!/bin/bash
#
# Generate .env file for Sandbox Project
# This script is self-contained and uses relative paths from its location
#

set -e

# Get script directory and project root
SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" && pwd)"
PROJECT_ROOT="$(cd "$SCRIPT_DIR/.." && pwd)"

# Fixed paths relative to project root
CONFIG_FILE="$PROJECT_ROOT/sandbox.config"
ENV_FILE="$PROJECT_ROOT/.env"
EXAMPLE_FILE="$PROJECT_ROOT/sandbox.config.example"

# Detect timezone
detect_timezone() {
    if [ -n "$TZ" ]; then
        echo "$TZ"
    elif [ -L /etc/localtime ]; then
        readlink /etc/localtime | sed 's|.*/zoneinfo/||'
    elif [ -f /etc/timezone ]; then
        cat /etc/timezone
    elif command -v timedatectl >/dev/null 2>&1; then
        timedatectl | grep "Time zone" | awk '{print $3}'
    else
        echo "Asia/Tokyo"
    fi
}

# Detect git root (fallback to project root if not in git repo)
detect_git_root() {
    git -C "$PROJECT_ROOT" rev-parse --show-toplevel 2>/dev/null || echo "$PROJECT_ROOT"
}

# Convert full path to short form using ~
convert_to_short_path() {
    local full_path="$1"
    local home_path="$HOME"
    
    # Replace home directory path with ~
    if [[ "$full_path" == "$home_path"* ]]; then
        echo "${full_path/#$home_path/~}"
    else
        echo "$full_path"
    fi
}

# Generate Docker-compliant container name from path
generate_container_name() {
    local source_path="$1"
    
    # First, convert to short path using existing function
    local short_path=$(convert_to_short_path "$source_path")
    
    # Remove leading ~/ if present
    local clean_path=$(echo "$short_path" | sed 's|^~/||')
    
    # Replace all slashes with hyphens
    local container_name=$(echo "$clean_path" | tr '/' '-')
    
    # Keep only valid Docker container name characters
    container_name=$(echo "$container_name" | tr -cd 'a-zA-Z0-9._-')
    
    # Remove leading non-alphanumeric characters
    container_name=$(echo "$container_name" | sed 's/^[^a-zA-Z0-9]*//')
    
    # Handle empty or number-starting names
    if [ -z "$container_name" ] || [[ "$container_name" =~ ^[0-9] ]]; then
        container_name="sandbox-${container_name}"
    fi
    
    # No prefix needed - the path itself is descriptive enough
    
    # Limit length for Docker constraints (max 63 chars)
    if [ ${#container_name} -gt 63 ]; then
        container_name="${container_name:0:63}"
    fi
    
    echo "$container_name"
}

# Main generation function
generate_env_file() {
    echo "üîß Generating .env file..."
    
    # Check if config file exists
    if [ ! -f "$CONFIG_FILE" ]; then
        echo "‚ùå Error: $CONFIG_FILE not found!"
        echo "üìù Please create it from sandbox.config.example:"
        echo "   cp $EXAMPLE_FILE $CONFIG_FILE"
        exit 1
    fi
    
    # Get system values
    local detected_tz=$(detect_timezone)
    local git_root=$(detect_git_root)
    local current_user=$(whoami)
    
    # Start generating .env file
    cat > "$ENV_FILE" << EOF
# Auto-generated by scripts/generate-env.sh - DO NOT EDIT
# Generated at: $(date)

# User Configuration
EOF
    
    # Extract all environment variables from config (excluding comments and empty lines)
    grep -E '^[[:space:]]*[A-Z_][A-Z0-9_]*[[:space:]]*=' "$CONFIG_FILE" | \
        sed 's/[[:space:]]*=[[:space:]]*/=/' >> "$ENV_FILE" || true
    
    # Add TZ if not already set
    if ! grep -q "^TZ=" "$ENV_FILE"; then
        echo "TZ=$detected_tz" >> "$ENV_FILE"
    fi
    
    # Add auto-detected values
    cat >> "$ENV_FILE" << EOF

# Auto-detected Values
HOST_SANDBOX_PATH=$git_root
HOST_USERNAME=$current_user
EOF
    
    # Extract SOURCE_PATH and set HOST_PRODUCT_PATH
    local source_path=$(grep -E '^[[:space:]]*SOURCE_PATH[[:space:]]*=' "$CONFIG_FILE" | \
        sed 's/^[^=]*=//' | xargs)
    if [ -n "$source_path" ]; then
        echo "HOST_PRODUCT_PATH=$source_path" >> "$ENV_FILE"
        
        # Generate CONTAINER_NAME from SOURCE_PATH
        local container_name=$(generate_container_name "$source_path")
        echo "CONTAINER_NAME=$container_name" >> "$ENV_FILE"
    fi
    
    echo "" >> "$ENV_FILE"
    echo "‚úÖ .env file generated successfully!"
}

# Validate the generated configuration
validate_config() {
    echo "üîç Validating configuration..."
    
    if ! grep -q "^SOURCE_PATH=.." "$ENV_FILE"; then
        echo "‚ùå Error: Source path is not set in $CONFIG_FILE"
        echo "   This is a required setting."
        exit 1
    fi
    
    local source_path=$(grep "^SOURCE_PATH=" "$ENV_FILE" | cut -d'=' -f2)
    if [ ! -d "$source_path" ]; then
        echo "‚ö†Ô∏è  Warning: Source path '$source_path' does not exist"
        echo "   Container will start but the directory will be empty"
    fi
    
    if ! grep -q "^GH_TOKEN=.." "$ENV_FILE"; then
        echo "‚ÑπÔ∏è  Note: GitHub token is not set"
        echo "   Some features may be limited"
    fi
    
    echo "‚úÖ Configuration is valid!"
}

# Main execution
main() {
    generate_env_file
    
    # Validate if requested (check for --validate argument)
    if [ "$1" = "--validate" ]; then
        validate_config
    fi
}

# Run main function
main "$@"