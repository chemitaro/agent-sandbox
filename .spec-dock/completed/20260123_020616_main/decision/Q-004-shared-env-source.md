---
種別: 設計補助資料（意思決定レポート）
機能ID: "FEAT-005"
論点ID: "design.md Q-004"
論点名: "dynamic モードの共有 env の入力源"
作成者: "Codex CLI"
最終更新: "2026-01-22"
関連: ["../design.md", "../requirement.md"]
---

# Q-004: dynamic モードの共有 env（秘密情報/任意 env）の入力源（ベストプラクティス提案）

## 0. この論点は何を決めるか（結論の影響）
dynamic 起動（`sandbox`）は「どのディレクトリでも起動できる」「同一ツールで複数コンテナを並行稼働できる」ことが目的です。  
一方で、Claude/Codex/Gemini/OpenCode などは `GH_TOKEN` / `GEMINI_API_KEY` 等の環境変数（秘密情報を含む）があると便利です。

ここで決めたいのは、**dynamic 起動時にコンテナへ渡す env をどう分離・供給するのが運用/安全/実装の観点で最適か**です。

重要な要件制約（`@../requirement.md`）:
- コンテナ（インスタンス）ごとに `.env` や compose yaml を生成して保持しない
- 1つの `docker-compose.yml` を使い回し、インスタンス固有値は起動時に注入する

結論から言うと、best practice は **「秘密情報/共通 env は 1つの静的ファイル」「動的値は起動スクリプトから `docker compose` 実行時に注入」**の分離です。

また、ユーザー要望として **「Docker Compose が自動で読む `.env` を使いたい（= プロジェクトルートに `.env` を置きたい）」** があります。

---

## 0.1 決定（ユーザー回答反映）
- 採用: **選択肢A**
- 共有 env（秘密情報/共通 env）のファイル: **`agent-sandbox` リポジトリ直下の `.env`**
  - `.agent-home` には置かない（用途が “各エージェントの設定/キャッシュ” であり、`env` の置き場としては分かりにくいため）
- `.env` の方針: **ユーザー管理の静的ファイル**（git-ignored）。ツールは **自動生成/上書きしない**。
- 動的値の方針: **ファイル合成せず**、起動スクリプトが `docker compose` 実行時に注入する（複数コンテナ並行でも衝突しない）。

---

## 1. As-Is（現状）と問題
### As-Is（根拠）
- `docker-compose.yml` は `env_file: .env` を読み、コンテナへ環境変数を渡している（`docker-compose.yml:54-55`）。
- `.env` は `scripts/generate-env.sh` が `sandbox.config` から生成する（`scripts/generate-env.sh:123-170`）。
  - `sandbox.config` は `SOURCE_PATH` / `PRODUCT_NAME` / `GH_TOKEN` 等を保持する（`sandbox.config.example`）。

### 問題（dynamic モードで変わる前提）
dynamic モードでは、インスタンスごとに `mount-root/workdir/container_name` が変わります。  
この “動的に変わる値” をファイルに合成してしまうと、次の問題が出ます。

- 1つの clone で複数コンテナを並行運用するとき、**ファイルが上書きされる**（またはインスタンスごとに増殖する）
- legacy（`make start`）が `.env` を使うため、**互換性/混線**が起きやすい

一方、秘密情報（APIキー等）は **インスタンスに依存しない共通値**であり、起動のたびに合成する必然性が薄いです。

---

## 1.5 重要: Docker Compose の “2種類の env”
混乱しやすいので、ここで前提を整理します。

1) **compose の変数展開（interpolation）に使う env**
   - `${VAR}` の置換に使われる
   - `docker compose` を実行するプロセス環境（`VAR=... docker compose ...`）や、**プロジェクトルートの `.env`**（規約）等から供給される

2) **コンテナ内へ渡す env**
   - compose の `environment:` と `env_file:` で渡す

best practice は、この2つを “同じ `.env` に全部詰め込む” のではなく、
- **秘密情報（コンテナに渡したい共通 env）**は `env_file` 側へ
- **インスタンス固有の動的値（compose 変数展開・DoD・volume 等に必要）**は起動スクリプトで注入
に分離することです。

---

## 2. 判断基準（ユーザーが選びやすい評価軸）
1) **要件整合**: per-instance の生成物増殖を起こさないか  
2) **起動の成功率**: 任意ディレクトリから起動しても “必要な env が欠けない” 状態を作れるか  
3) **運用負荷**: 設定場所が増えすぎないか、更新漏れが起きないか  
4) **セキュリティ/意図しない漏洩**: 秘密情報が不用意に広がらないか（ファイル/プロセス環境/ログ）  
5) **実装の単純さ**: Bash で堅牢に実装でき、テスト可能か

---

## 3. 選択肢

### 選択肢A（推奨）: “秘密情報/共通 env は 1つの静的ファイル”、動的値は起動スクリプトで注入
#### 3.1 具体像（どう動くか）
- ユーザーが **プロジェクトルートに `.env` を1つ**作り、ここに “持ち込みたい秘密情報/共通 env” を記載する。
  - 例: `GH_TOKEN`, `GEMINI_API_KEY`, `SLACK_WEBHOOK_URL`, `PRE_COMMIT_VERSION` など
- dynamic 起動スクリプトは、以下を “起動時に” 計算して `docker compose` の実行環境として渡す（= ファイル合成しない）:
  - `CONTAINER_NAME`（instance key から決定的に）
  - `SOURCE_PATH=abs_mount_root`
  - `PRODUCT_WORK_DIR=/srv/mount`
  - `HOST_SANDBOX_PATH=<agent-sandbox root>`
  - `HOST_USERNAME=<whoami>`
  - `PRODUCT_NAME=mount`（dynamic 固定）
- `docker-compose.yml` は `env_file: .env`（現状維持）とし、コンテナ内にも secrets を渡す。
- dynamic 起動スクリプトは **動的値のみ** を `docker compose` 実行時に注入する（`.env` は合成しない）。
  - 重要: 起動スクリプトは `agent-sandbox` ルートで `docker compose` を実行する（`cd` または `--project-directory`）ことで、`.env` が確実に読み込まれるようにする。

#### 3.1.1 “静的 env ファイル” に入れるもの / 入れないもの（判断基準）
- 入れる（共通・秘密情報・任意の固定値）:
  - APIキー、トークン、Webhook URL
  - `TZ` のような「全コンテナ共通で固定したい」値
- 入れない（インスタンスで変わる／自動収集される）:
  - `SOURCE_PATH`（mount-root はインスタンスごとに違う）
  - `CONTAINER_NAME`
  - `PRODUCT_WORK_DIR`（dynamic は `/srv/mount` 固定）
  - `HOST_SANDBOX_PATH` / `HOST_USERNAME`

#### 3.2 メリット
- **インスタンス固有値をファイルに書かない**ため、複数コンテナ並行でも衝突しない。
- env ファイルは **1つだけ**（増殖しない）で、要件の「運用負荷を増やさない」に整合する。
- 起動スクリプトで動的値を注入するため、**常に正しい値**で起動できる（ファイル更新漏れを避けられる）。
- `docker compose` の一般的な運用（静的 env + runtime env）に沿っており、説明/理解がしやすい。

#### 3.3 デメリット / リスク
- 静的 env ファイルをユーザーが用意する必要がある（初回だけ）。
  - 対策: `sandbox env init` 的なコマンド（またはテンプレ）を提供してガイドする（任意）。
- 秘密情報が平文でファイルに書かれる点は従来の `.env` と同様。
  - 対策: `.env` は git-ignored のままにし、`chmod 600` を推奨。ログには値を出さない。

#### 3.4 推奨理由（なぜAか）
ユーザーが提示した方針（「動的値は起動時に渡す」「env ファイルは秘密情報だけ」）が、要件と実装都合の両面で最も矛盾が少ないためです。

- “複数コンテナ” を前提にしたとき、**ファイル合成は衝突しやすい**（上書き/増殖のどちらかになる）
- 動的値はスクリプトが常に持っている（計算できる）ので、**ファイルに落とす必要がない**
- 一方、秘密情報は “共通で固定” が自然で、1ファイルに集約できる
- legacy は `.env` のまま残せるため、互換性の面でも安全

---

### 選択肢B: `sandbox.config` を入力として使い、共有 env を 1 つ生成して参照する（自動生成）
#### 3.5 具体像
- dynamic 起動時、`agent-sandbox` リポジトリ内に **共有 env ファイル**を自動生成する（例: `agent-sandbox/.agent-home/sandbox.env`）。
- そこへ `sandbox.config` の値を反映する（ただし `SOURCE_PATH` / `PRODUCT_NAME` は dynamic では無視）。
- dynamic 値は A と同様に起動時注入する（※全部をファイルへ合成はしない）。

#### 3.6 メリット
- 初回セットアップが楽（ユーザーが env ファイルを手作業で書かなくてよい）。
- 既存の `sandbox.config` 運用資産をそのまま使える。

#### 3.7 デメリット / リスク
- “ファイル生成しない” 志向とややズレる（ただし 1ファイルに集約するなら要件には整合）。
- `sandbox.config` を秘密情報の保管場所として使い続けることになる（好みが分かれる）。

---

### 選択肢C: env ファイルは持たず、ホスト環境変数のみで渡す
#### 3.5 具体像
- dynamic 起動では env ファイルを生成せず、`GH_TOKEN` 等はユーザーがシェルの環境変数として export しておく。
- `docker compose` 実行時にその環境を引き継いでコンテナに渡す（compose 側の `environment:` のみで拾えるものは拾う）。

#### 3.6 メリット
- **新規ファイルが増えない**（生成ゼロ）。
- “どの sandbox clone を参照するか” の概念が薄く、単純に見える。

#### 3.7 デメリット / リスク
- ユーザーの起動環境（シェル/direnv/tmux）に依存し、**起動成功率が下がりやすい**。
- `make start`（legacy）と `sandbox`（dynamic）で “env の供給源” が分裂し、運用が複雑化しやすい。
- `export` した秘密情報はプロセス環境に残るため、意図せず他プロセスへ波及する懸念がある。

---

## 4. 推奨（結論）
**決定は A**（ユーザー管理の “静的 secrets env（.env）” + 起動時注入）です。

補足:
- ただし「初回セットアップを楽にしたい」場合のみ、B（自動生成）を採る価値があります。
- （将来的に必要なら）`--env-file` 相当の上書きを用意すると、運用の逃げ道（個人の安全な場所へ置く等）が作れます。

---

## 5. 運用メモ（設計に反映する具体ルール）
- `.env` が存在しない場合は、起動スクリプト側で **空の `.env` を作成**して起動を継続する（※ `env_file` は存在しないと失敗し得るため）。
- `.env` の内容はログに出さない（キー名のみ可）。
- `.env` は git-ignored のまま維持する（現状 `.gitignore` に含まれている）。

---

## 6. 重要な設計論点: 現状の `generate-env.sh` が `.env` を上書きする問題
現状の legacy フローでは `scripts/generate-env.sh` が `.env` を生成/上書きします（`scripts/generate-env.sh:123-170`）。  
そのまま `.env` を secrets ファイルとしてユーザーが管理すると、**legacy の実行で secrets が上書きされる**事故が起きます。

このため、`.env` を採用する場合は次のいずれかが必須です（推奨順）。

- 採用（今回の設計方針）: legacy も含めて「動的値は起動時注入」に寄せ、**`.env` を自動生成しない**（`.env` はユーザー管理の secrets として固定）
- 代替（採用しない）: legacy の生成先を `.env.legacy` 等に変更し、compose 側を調整（ただし “ファイルを増やす/マージ” が発生しやすい）
