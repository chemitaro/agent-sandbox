#!/bin/bash
set -euo pipefail

CALLER_PWD="${CALLER_PWD:-$(pwd)}"
CODEX_SANDBOX_ARGS=()
CODEX_ARGS=()
CODEX_HAS_DOUBLE_DASH=false
TOOLS_UPDATE_LOCK_DIR=""
MAX_UP_LEVEL=1
FORBIDDEN_MOUNT_ROOTS=(
    "/"
    "$HOME"
    "/Users"
    "/home"
    "/Volumes"
    "/mnt"
    "/media"
)

realpath_safe() {
    local target="$1"
    if command -v realpath >/dev/null 2>&1; then
        local resolved
        if resolved="$(realpath "$target" 2>/dev/null)"; then
            echo "$resolved"
            return 0
        fi
    fi
    local link_target="$target"
    if command -v readlink >/dev/null 2>&1; then
        while [[ -L "$link_target" ]]; do
            local link
            link="$(readlink "$link_target" 2>/dev/null || true)"
            if [[ -z "$link" ]]; then
                break
            fi
            if [[ "$link" != /* ]]; then
                link_target="$(dirname "$link_target")/$link"
            else
                link_target="$link"
            fi
        done
    fi
    if [[ -d "$link_target" ]]; then
        (cd -P "$link_target" && pwd -P)
        return $?
    fi
    local dir
    dir="$(cd -P "$(dirname "$link_target")" && pwd -P)" || return 1
    printf '%s/%s\n' "$dir" "$(basename "$link_target")"
}

SCRIPT_PATH="$(realpath_safe "${BASH_SOURCE[0]}")"
SANDBOX_ROOT="$(realpath_safe "$(dirname "$SCRIPT_PATH")/..")"

resolve_path() {
    local input="$1"
    local target
    if [[ "$input" == /* ]]; then
        target="$input"
    else
        target="$CALLER_PWD/$input"
    fi
    if [[ ! -e "$target" && ! -L "$target" ]]; then
        echo "path does not exist: $target" >&2
        return 1
    fi
    if ! realpath_safe "$target"; then
        return 1
    fi
}

ensure_directory() {
    local path="$1"
    local label="$2"
    if [[ -e "$path" && ! -d "$path" ]]; then
        echo "$label is not a directory: $path" >&2
        return 1
    fi
    if [[ ! -d "$path" ]]; then
        echo "$label does not exist: $path" >&2
        return 1
    fi
    return 0
}

ensure_env_file() {
    local env_file="$SANDBOX_ROOT/.env"
    if [[ ! -f "$env_file" ]]; then
        : > "$env_file"
    fi
}

ensure_agent_home_dirs() {
    local base="$SANDBOX_ROOT/.agent-home"
    mkdir -p \
        "$base/.claude" \
        "$base/.codex" \
        "$base/.gemini" \
        "$base/.opencode" \
        "$base/.opencode/agent" \
        "$base/.opencode/command" \
        "$base/.opencode/plugin" \
        "$base/.opencode-data" \
        "$base/.cache/uv" \
        "$base/.cache/pre-commit" \
        "$base/.cache/opencode" \
        "$base/commandhistory"
}

detect_timezone() {
    if [[ -n "${TZ:-}" ]]; then
        echo "$TZ"
        return 0
    fi
    if [[ -L /etc/localtime ]]; then
        local target
        target="$(readlink /etc/localtime 2>/dev/null || true)"
        if [[ "$target" == *"/zoneinfo/"* ]]; then
            echo "${target##*/zoneinfo/}"
            return 0
        fi
    fi
    if [[ -f /etc/timezone ]]; then
        local tz
        tz="$(cat /etc/timezone)"
        if [[ -n "$tz" ]]; then
            echo "$tz"
            return 0
        fi
    fi
    if command -v systemsetup >/dev/null 2>&1; then
        local tz
        tz="$(systemsetup -gettimezone 2>/dev/null | awk -F': ' '{print $2}' || true)"
        if [[ -n "$tz" ]]; then
            echo "$tz"
            return 0
        fi
    fi
    if command -v timedatectl >/dev/null 2>&1; then
        local tz
        tz="$(timedatectl 2>/dev/null | awk -F'[: ]+' '/Time zone/ {print $3}' || true)"
        if [[ -n "$tz" ]]; then
            echo "$tz"
            return 0
        fi
    fi
    echo "Asia/Tokyo"
}

env_file_has_tz_nonempty() {
    local env_file="$SANDBOX_ROOT/.env"
    if [[ ! -f "$env_file" ]]; then
        return 1
    fi
    while IFS= read -r line; do
        line="${line%%#*}"
        if [[ "$line" =~ ^[[:space:]]*TZ= ]]; then
            local value="${line#*=}"
            value="${value%$'\\r'}"
            value="$(echo "$value" | sed -E 's/^[[:space:]]+//; s/[[:space:]]+$//')"
            value="${value%\"}"
            value="${value#\"}"
            value="${value%\'}"
            value="${value#\'}"
            if [[ -n "$value" ]]; then
                return 0
            fi
        fi
    done < "$env_file"
    return 1
}

resolve_tz_injection() {
    if [[ -n "${TZ:-}" ]]; then
        return 1
    fi
    if env_file_has_tz_nonempty; then
        return 1
    fi
    return 0
}

select_compose_cmd() {
    if docker compose version >/dev/null 2>&1; then
        COMPOSE_CMD=("docker" "compose")
        return 0
    fi

    if command -v docker-compose >/dev/null 2>&1; then
        local ver
        ver="$(docker-compose version 2>/dev/null || true)"
        if echo "$ver" | grep -qi "version v2"; then
            COMPOSE_CMD=("docker-compose")
            return 0
        fi
    fi

    echo "docker compose v2 is required" >&2
    return 1
}

prepare_compose_env() {
    local container_name="$1"
    local compose_project_name="$2"
    local abs_mount_root="$3"

    local tz_env=()
    if resolve_tz_injection; then
        tz_env=("TZ=$(detect_timezone)")
    fi

    local host_username
    host_username="$(whoami)"

    COMPOSE_ENV=(
        "CONTAINER_NAME=$container_name"
        "COMPOSE_PROJECT_NAME=$compose_project_name"
        "SOURCE_PATH=$abs_mount_root"
        "PRODUCT_WORK_DIR=/srv/mount"
        "HOST_SANDBOX_PATH=$SANDBOX_ROOT"
        "HOST_USERNAME=$host_username"
        "PRODUCT_NAME=mount"
    )

    if [[ ${#tz_env[@]} -gt 0 ]]; then
        COMPOSE_ENV+=("${tz_env[@]}")
    fi
}

run_compose() {
    ( cd "$SANDBOX_ROOT" && env "${COMPOSE_ENV[@]}" "${COMPOSE_CMD[@]}" "$@" )
}

run_compose_up() {
    local container_name="$1"
    local compose_project_name="$2"
    local abs_mount_root="$3"

    prepare_compose_env "$container_name" "$compose_project_name" "$abs_mount_root"
    run_compose up -d --build
}

run_compose_exec() {
    local container_workdir="$1"
    local container_name="$2"
    local compose_project_name="$3"
    local abs_mount_root="$4"
    prepare_compose_env "$container_name" "$compose_project_name" "$abs_mount_root"
    run_compose exec -w "$container_workdir" agent-sandbox /bin/zsh
}

run_compose_exec_codex() {
    local container_workdir="$1"
    local container_name="$2"
    local compose_project_name="$3"
    local abs_mount_root="$4"
    shift 4
    prepare_compose_env "$container_name" "$compose_project_name" "$abs_mount_root"
    if [[ $# -gt 0 ]]; then
        run_compose exec -w "$container_workdir" agent-sandbox /bin/zsh -lc 'codex resume "$@"; exec /bin/zsh' -- "$@"
    else
        run_compose exec -w "$container_workdir" agent-sandbox /bin/zsh -lc 'codex resume; exec /bin/zsh'
    fi
}

run_compose_build() {
    local container_name="$1"
    local compose_project_name="$2"
    local abs_mount_root="$3"
    shift 3

    prepare_compose_env "$container_name" "$compose_project_name" "$abs_mount_root"
    run_compose build "$@"
}

run_compose_run() {
    local container_name="$1"
    local compose_project_name="$2"
    local abs_mount_root="$3"
    shift 3

    prepare_compose_env "$container_name" "$compose_project_name" "$abs_mount_root"
    run_compose run "$@"
}

parse_common_args() {
    MOUNT_ROOT_ARG=""
    WORKDIR_ARG=""

    while [[ $# -gt 0 ]]; do
        case "$1" in
            --mount-root)
                if [[ $# -lt 2 ]]; then
                    echo "Missing value for --mount-root" >&2
                    exit 1
                fi
                MOUNT_ROOT_ARG="$2"
                shift 2
                ;;
            --workdir)
                if [[ $# -lt 2 ]]; then
                    echo "Missing value for --workdir" >&2
                    exit 1
                fi
                WORKDIR_ARG="$2"
                shift 2
                ;;
            *)
                shift
                ;;
        esac
    done
}

extract_tools_action() {
    local args=("$@")
    local i=0

    while [[ $i -lt ${#args[@]} ]]; do
        local arg="${args[$i]}"
        if [[ "$arg" == "--" ]]; then
            break
        fi
        case "$arg" in
            --mount-root|--workdir)
                i=$((i + 2))
                continue
                ;;
            -*)
                i=$((i + 1))
                continue
                ;;
        esac
        if [[ "$arg" == "tools" ]]; then
            i=$((i + 1))
            break
        fi
        i=$((i + 1))
    done

    while [[ $i -lt ${#args[@]} ]]; do
        local arg="${args[$i]}"
        if [[ "$arg" == "--" ]]; then
            break
        fi
        case "$arg" in
            --mount-root|--workdir)
                i=$((i + 2))
                continue
                ;;
            -*)
                i=$((i + 1))
                continue
                ;;
        esac
        echo "$arg"
        return 0
    done

    echo ""
    return 0
}

acquire_tools_update_lock() {
    TOOLS_UPDATE_LOCK_DIR="${SANDBOX_TOOLS_UPDATE_LOCK_DIR:-/tmp/sandbox-tools-update.lock}"
    if mkdir "$TOOLS_UPDATE_LOCK_DIR" 2>/dev/null; then
        trap 'rm -rf "$TOOLS_UPDATE_LOCK_DIR"' EXIT
        return 0
    fi
    echo "Another tools update is in progress (lock: $TOOLS_UPDATE_LOCK_DIR)" >&2
    return 1
}

split_codex_args() {
    CODEX_SANDBOX_ARGS=()
    CODEX_ARGS=()
    CODEX_HAS_DOUBLE_DASH=false

    local seen_double_dash=false
    for arg in "$@"; do
        if [[ "$seen_double_dash" == false && "$arg" == "--" ]]; then
            seen_double_dash=true
            CODEX_HAS_DOUBLE_DASH=true
            continue
        fi
        if [[ "$seen_double_dash" == true ]]; then
            CODEX_ARGS+=("$arg")
        else
            CODEX_SANDBOX_ARGS+=("$arg")
        fi
    done
}

codex_args_have_conflicts() {
    local arg
    for arg in "${CODEX_ARGS[@]}"; do
        case "$arg" in
            --yolo|--dangerously-bypass-approvals-and-sandbox)
                return 0
                ;;
            --sandbox|-s|--ask-for-approval|-a|--profile|-p|--config|-c|--cd|-C)
                return 0
                ;;
            --sandbox=*|--ask-for-approval=*|--profile=*|--config=*|--cd=*)
                return 0
                ;;
            -C*|-c*|-a*|-s*|-p*)
                return 0
                ;;
        esac
    done
    return 1
}

determine_paths() {
    if [[ -n "$MOUNT_ROOT_ARG" && -n "$WORKDIR_ARG" ]]; then
        if ! ABS_MOUNT_ROOT="$(resolve_path "$MOUNT_ROOT_ARG")"; then
            return 1
        fi
        if ! ABS_WORKDIR="$(resolve_path "$WORKDIR_ARG")"; then
            return 1
        fi
        if ! ensure_directory "$ABS_MOUNT_ROOT" "mount-root"; then
            return 1
        fi
        if ! ensure_directory "$ABS_WORKDIR" "workdir"; then
            return 1
        fi
        if ! is_subpath "$ABS_MOUNT_ROOT" "$ABS_WORKDIR"; then
            echo "workdir must be within mount-root" >&2
            return 1
        fi
        return 0
    fi

    if [[ -n "$MOUNT_ROOT_ARG" ]]; then
        if ! ABS_MOUNT_ROOT="$(resolve_path "$MOUNT_ROOT_ARG")"; then
            return 1
        fi
        if ! ensure_directory "$ABS_MOUNT_ROOT" "mount-root"; then
            return 1
        fi
        ABS_WORKDIR="$ABS_MOUNT_ROOT"
        if ! is_subpath "$ABS_MOUNT_ROOT" "$ABS_WORKDIR"; then
            echo "workdir must be within mount-root" >&2
            return 1
        fi
        return 0
    fi

    if [[ -n "$WORKDIR_ARG" ]]; then
        if ! ABS_WORKDIR="$(resolve_path "$WORKDIR_ARG")"; then
            return 1
        fi
        if ! ensure_directory "$ABS_WORKDIR" "workdir"; then
            return 1
        fi
        if auto_detect_mount_root "$ABS_WORKDIR"; then
            ABS_MOUNT_ROOT="$AUTO_MOUNT_ROOT"
        else
            local rc=$?
            if [[ $rc -eq 10 ]]; then
                ABS_MOUNT_ROOT="$ABS_WORKDIR"
                if ! guard_mount_root "$ABS_MOUNT_ROOT" ""; then
                    return 1
                fi
            else
                return 1
            fi
        fi
        if ! ensure_directory "$ABS_MOUNT_ROOT" "mount-root"; then
            return 1
        fi
        if ! is_subpath "$ABS_MOUNT_ROOT" "$ABS_WORKDIR"; then
            echo "workdir must be within mount-root" >&2
            return 1
        fi
        return 0
    fi

    if ! ABS_WORKDIR="$(resolve_path "$CALLER_PWD")"; then
        return 1
    fi
    if ! ensure_directory "$ABS_WORKDIR" "workdir"; then
        return 1
    fi
    if auto_detect_mount_root "$ABS_WORKDIR"; then
        ABS_MOUNT_ROOT="$AUTO_MOUNT_ROOT"
    else
        local rc=$?
        if [[ $rc -eq 10 ]]; then
            ABS_MOUNT_ROOT="$ABS_WORKDIR"
            if ! guard_mount_root "$ABS_MOUNT_ROOT" ""; then
                return 1
            fi
        else
            return 1
        fi
    fi
    if ! ensure_directory "$ABS_MOUNT_ROOT" "mount-root"; then
        return 1
    fi
    if ! is_subpath "$ABS_MOUNT_ROOT" "$ABS_WORKDIR"; then
        echo "workdir must be within mount-root" >&2
        return 1
    fi
    return 0
}

is_subpath() {
    local root="$1"
    local path="$2"
    root="${root%/}"
    path="${path%/}"

    if [[ "$path" == "$root" ]]; then
        return 0
    fi
    if [[ "$path" == "$root/"* ]]; then
        return 0
    fi
    return 1
}

compute_container_workdir() {
    local abs_mount_root="$1"
    local abs_workdir="$2"

    if ! is_subpath "$abs_mount_root" "$abs_workdir"; then
        echo "workdir must be within mount-root" >&2
        return 1
    fi

    if [[ "$abs_mount_root" == "$abs_workdir" ]]; then
        echo "/srv/mount"
        return 0
    fi

    local rel="${abs_workdir#$abs_mount_root/}"
    echo "/srv/mount/$rel"
}

codex_config_path() {
    echo "$SANDBOX_ROOT/.agent-home/.codex/config.toml"
}

is_codex_project_trusted() {
    local trust_key="$1"
    local config_path
    config_path="$(codex_config_path)"

    if [[ -z "$trust_key" ]]; then
        return 1
    fi
    if [[ ! -f "$config_path" ]]; then
        return 1
    fi

    if awk -v key="$trust_key" '
        BEGIN { in_section=0; found=0 }
        $0 ~ /^\[projects\./ {
            if (index($0, "[projects.\"" key "\"]") || index($0, "[projects.\047" key "\047]")) {
                in_section=1; next
            }
            in_section=0
        }
        in_section && ($0 ~ /trust_level[[:space:]]*=[[:space:]]*\"trusted\"/ \
            || $0 ~ /trust_level[[:space:]]*=[[:space:]]*'\''trusted'\''/) { found=1; exit }
        END { exit found ? 0 : 1 }
    ' "$config_path"; then
        return 0
    fi

    local compact
    compact="$(tr -d ' \t\r\n' < "$config_path")"
    if [[ "$compact" == *"\"$trust_key\"={trust_level=\"trusted\"}"* || "$compact" == *"\"$trust_key\"={trust_level=\"trusted\"},"* ]]; then
        return 0
    fi
    if [[ "$compact" == *"'$trust_key'={trust_level='trusted'}"* || "$compact" == *"'$trust_key'={trust_level='trusted'},"* ]]; then
        return 0
    fi

    return 1
}

compute_codex_mode() {
    local abs_mount_root="$1"
    local abs_workdir="$2"

    CODEX_GIT_STATE=""
    CODEX_TRUST_KEY=""
    CODEX_MODE=""
    CODEX_BOOTSTRAP_NOTICE=""
    CODEX_WARNING=""

    if find_git_marker "$abs_workdir"; then
        if repo_root="$(git -C "$abs_workdir" rev-parse --show-toplevel 2>/dev/null)"; then
            repo_root="$(resolve_path "$repo_root")" || return 1
            CODEX_GIT_STATE="git_ok"
            CODEX_TRUST_KEY="$(compute_container_workdir "$abs_mount_root" "$repo_root")" || return 1
            if is_codex_project_trusted "$CODEX_TRUST_KEY"; then
                CODEX_MODE="yolo"
            else
                CODEX_MODE="bootstrap"
                CODEX_BOOTSTRAP_NOTICE="sandbox codex: Trust が未設定のため bootstrap で起動します。Trust を実行してから再実行してください。"
            fi
        else
            CODEX_GIT_STATE="git_error"
            CODEX_MODE="bootstrap"
            CODEX_WARNING="sandbox codex: failed to detect git root (rev-parse)"
            CODEX_BOOTSTRAP_NOTICE="sandbox codex: Trust が未設定のため bootstrap で起動します。Trust を実行してから再実行してください。"
        fi
    else
        CODEX_GIT_STATE="non_git"
        CODEX_MODE="yolo"
    fi

    return 0
}

find_git_marker() {
    local dir="$1"
    dir="$(resolve_path "$dir")"
    while true; do
        if [[ -e "$dir/.git" ]]; then
            return 0
        fi
        if [[ "$dir" == "/" ]]; then
            return 1
        fi
        dir="$(dirname "$dir")"
    done
}

compute_lca() {
    local first="$1"
    shift

    local lca
    lca="$(resolve_path "$first")"

    for path in "$@"; do
        local abs_path
        abs_path="$(resolve_path "$path")"
        while ! is_subpath "$lca" "$abs_path"; do
            if [[ "$lca" == "/" ]]; then
                break
            fi
            lca="$(dirname "$lca")"
        done
    done

    echo "$lca"
}

guard_mount_root() {
    local mount_root="$1"
    local repo_root="$2"

    for forbidden in "${FORBIDDEN_MOUNT_ROOTS[@]}"; do
        if [[ "$mount_root" == "$forbidden" ]]; then
            echo "mount-root is too broad: $mount_root" >&2
            return 1
        fi
    done

    if [[ -n "$repo_root" ]]; then
        local up_level=0
        local cursor="$repo_root"
        while [[ "$cursor" != "$mount_root" && "$cursor" != "/" ]]; do
            cursor="$(dirname "$cursor")"
            up_level=$((up_level + 1))
        done
        if [[ "$cursor" != "$mount_root" ]]; then
            echo "mount-root is not an ancestor of repo-root" >&2
            return 1
        fi
        if (( up_level > MAX_UP_LEVEL )); then
            echo "mount-root is too broad (up-level=$up_level)" >&2
            return 1
        fi
    fi

    return 0
}

auto_detect_mount_root() {
    local abs_workdir="$1"

    if ! find_git_marker "$abs_workdir"; then
        return 10
    fi

    local repo_root
    if ! repo_root="$(git -C "$abs_workdir" rev-parse --show-toplevel 2>/dev/null)"; then
        echo "failed to detect git root (rev-parse)" >&2
        return 1
    fi
    repo_root="$(resolve_path "$repo_root")"

    local worktree_paths=()
    while IFS= read -r line; do
        if [[ "$line" == worktree\ * ]]; then
            local path="${line#worktree }"
            if [[ -d "$path" ]]; then
                worktree_paths+=("$path")
            else
                echo "skip missing worktree: $path" >&2
            fi
        fi
    done < <(git -C "$repo_root" worktree list --porcelain 2>/dev/null)

    if [[ ${#worktree_paths[@]} -eq 0 ]]; then
        worktree_paths+=("$repo_root")
    else
        local has_repo_root=false
        local wt
        for wt in "${worktree_paths[@]}"; do
            if [[ "$wt" == "$repo_root" ]]; then
                has_repo_root=true
                break
            fi
        done
        if [[ "$has_repo_root" == false ]]; then
            worktree_paths+=("$repo_root")
        fi
    fi

    local lca
    lca="$(compute_lca "${worktree_paths[@]}")"
    if [[ -z "$lca" ]]; then
        echo "failed to compute mount-root" >&2
        return 1
    fi

    if ! guard_mount_root "$lca" "$repo_root"; then
        return 1
    fi

    AUTO_MOUNT_ROOT="$lca"
    AUTO_REPO_ROOT="$repo_root"
    return 0
}

normalize_slug() {
    local raw="$1"
    local slug
    slug="$(echo "$raw" | sed -E 's/[^a-zA-Z0-9._-]+/-/g; s/^-+//; s/-+$//')"

    if [[ -z "$slug" ]]; then
        slug="dir"
    fi

    local max_slug_len=42
    if (( ${#slug} > max_slug_len )); then
        slug="${slug:0:max_slug_len}"
    fi

    echo "$slug"
}

normalize_compose_slug() {
    local raw="$1"
    local slug
    slug="$(echo "$raw" | tr '[:upper:]' '[:lower:]' | sed -E 's/[^a-z0-9_-]+/-/g; s/^-+//; s/-+$//')"

    if [[ -z "$slug" ]]; then
        slug="dir"
    fi

    local max_slug_len=42
    if (( ${#slug} > max_slug_len )); then
        slug="${slug:0:max_slug_len}"
    fi

    echo "$slug"
}

compute_hash12() {
    local key="$1"
    local digest=""

    if command -v sha256sum >/dev/null 2>&1; then
        digest="$(printf '%s' "$key" | sha256sum | awk '{print $1}')" || true
    fi

    if [[ -z "$digest" ]] && command -v shasum >/dev/null 2>&1; then
        digest="$(printf '%s' "$key" | shasum -a 256 | awk '{print $1}')" || true
    fi

    if [[ -z "$digest" ]]; then
        echo "Failed to compute sha256 hash" >&2
        exit 1
    fi

    echo "${digest:0:12}"
}

compute_container_name() {
    local abs_mount_root="$1"
    local abs_workdir="$2"

    local base_mount
    local base_workdir
    base_mount="$(basename "$abs_mount_root")"
    base_workdir="$(basename "$abs_workdir")"

    local slug_raw
    if [[ "$base_mount" == "$base_workdir" ]]; then
        slug_raw="$base_workdir"
    else
        slug_raw="${base_mount}-${base_workdir}"
    fi

    local slug
    slug="$(normalize_slug "$slug_raw")"

    local key
    key="${abs_mount_root}"$'\n'"${abs_workdir}"
    local hash12
    hash12="$(compute_hash12 "$key")"

    echo "sandbox-${slug}-${hash12}"
}

compute_compose_project_name() {
    local abs_mount_root="$1"
    local abs_workdir="$2"

    local base_mount
    local base_workdir
    base_mount="$(basename "$abs_mount_root")"
    base_workdir="$(basename "$abs_workdir")"

    local slug_raw
    if [[ "$base_mount" == "$base_workdir" ]]; then
        slug_raw="$base_workdir"
    else
        slug_raw="${base_mount}-${base_workdir}"
    fi

    local slug
    slug="$(normalize_compose_slug "$slug_raw")"

    local key
    key="${abs_mount_root}"$'\n'"${abs_workdir}"
    local hash12
    hash12="$(compute_hash12 "$key")"

    echo "sandbox-${slug}-${hash12}"
}

compute_codex_session_name() {
    local base
    base="$(basename "$CALLER_PWD")"
    base="${base//:/_}"
    base="${base//./_}"
    echo "${base}-codex-sandbox"
}

ensure_docker_available() {
    if ! command -v docker >/dev/null 2>&1; then
        echo "docker command not found" >&2
        return 1
    fi
    if ! docker info >/dev/null 2>&1; then
        echo "docker daemon is not reachable" >&2
        return 1
    fi
    return 0
}

ensure_tmux_available() {
    if ! command -v tmux >/dev/null 2>&1; then
        echo "tmux command not found" >&2
        return 1
    fi
    return 0
}

container_exists() {
    local container_name="$1"
    if docker inspect "$container_name" >/dev/null 2>&1; then
        return 0
    fi
    return 1
}

run_compose_stop() {
    local container_name="$1"
    local compose_project_name="$2"
    local abs_mount_root="$3"

    prepare_compose_env "$container_name" "$compose_project_name" "$abs_mount_root"
    run_compose stop
}

run_compose_down() {
    local container_name="$1"
    local compose_project_name="$2"
    local abs_mount_root="$3"

    prepare_compose_env "$container_name" "$compose_project_name" "$abs_mount_root"
    run_compose down
}

get_container_status() {
    local container_name="$1"
    local status
    local container_id

    status="$(docker inspect --format '{{.State.Status}}' "$container_name" 2>/dev/null)" || return 1
    container_id="$(docker inspect --format '{{.Id}}' "$container_name" 2>/dev/null)" || return 1

    CONTAINER_STATUS="$status"
    CONTAINER_ID_FULL="$container_id"
    return 0
}

print_help() {
    cat <<'USAGE'
Usage: sandbox <command> [options]

Commands:
  shell    Start (if needed) and open a shell (default)
  up       Build and start the container
  build    Build images only
  tools    Manage shared tools
  stop     Stop the container
  down     Stop and remove the container
  status   Show container status
  name     Print computed container name
  codex    Start tmux + sandbox + codex resume
  help     Show this help

Options:
  --mount-root <path>   Host mount root
  --workdir <path>      Host working directory
  -h, --help            Show help
USAGE
}

print_help_tools() {
    cat <<'USAGE'
Usage: sandbox tools <command> [options]

Commands:
  update   Update shared npm global tools (codex/claude/gemini/opencode, etc.)

Options:
  --mount-root <path>
  --workdir <path>
  -h, --help
USAGE
}

print_help_shell() {
    cat <<'USAGE'
Usage: sandbox shell [options]

Start (if needed) and open a shell inside the container.
Options:
  --mount-root <path>
  --workdir <path>
  -h, --help
USAGE
}

print_help_up() {
    cat <<'USAGE'
Usage: sandbox up [options]

Build and start the container.
Options:
  --mount-root <path>
  --workdir <path>
  -h, --help
USAGE
}

print_help_build() {
    cat <<'USAGE'
Usage: sandbox build [options]

Build images only.
Options:
  --no-cache           (default) Do not use cache when building the image
  --cache              Use cache when building the image
  --mount-root <path>
  --workdir <path>
  -h, --help
USAGE
}

print_help_stop() {
    cat <<'USAGE'
Usage: sandbox stop [options]

Stop the container.
Options:
  --mount-root <path>
  --workdir <path>
  -h, --help
USAGE
}

print_help_down() {
    cat <<'USAGE'
Usage: sandbox down [options]

Stop and remove the container.
Options:
  --mount-root <path>
  --workdir <path>
  -h, --help
USAGE
}

print_help_status() {
    cat <<'USAGE'
Usage: sandbox status [options]

Show container status.
Options:
  --mount-root <path>
  --workdir <path>
  -h, --help
USAGE
}

print_help_name() {
    cat <<'USAGE'
Usage: sandbox name [options]

Print computed container name.
Options:
  --mount-root <path>
  --workdir <path>
  -h, --help
USAGE
}

print_help_codex() {
    cat <<'USAGE'
Usage: sandbox codex [options] -- [codex args...]

Create/attach a tmux session, start the sandbox, and run "codex resume".
Options:
  --mount-root <path>
  --workdir <path>
  -h, --help
Notes:
  Trust状態に応じて bootstrap/YOLO を自動で切り替えます。
  未TrustのGitは bootstrap で起動します（Trust後に再実行するとYOLO）。
  非Gitは YOLO で起動します。
  競合する引数（--yolo/--sandbox/--ask-for-approval/--profile/--config/--cd など）を渡すとエラーになります。
  必要な場合は sandbox shell で codex を直接実行してください。
  Arguments after "--" are passed to codex (e.g., sandbox codex -- --help).
USAGE
}

main() {
    CALLER_PWD="${CALLER_PWD:-$(pwd)}"
    CODEX_SANDBOX_ARGS=()
    CODEX_ARGS=()
    CODEX_HAS_DOUBLE_DASH=false

    local subcommand=""
    local args=("$@")
    local i=0
    while [[ $i -lt ${#args[@]} ]]; do
        local arg="${args[$i]}"
        if [[ "$arg" == "--" ]]; then
            break
        fi
        case "$arg" in
            --mount-root|--workdir)
                i=$((i + 2))
                continue
                ;;
            -*)
                i=$((i + 1))
                continue
                ;;
        esac
        case "$arg" in
            shell|up|build|tools|stop|down|status|name|help|codex)
                subcommand="$arg"
            ;;
            *)
                subcommand="$arg"
            ;;
        esac
        break
    done

    local has_help_flag=false
    if [[ "$subcommand" == "codex" ]]; then
        split_codex_args "$@"
        for arg in "${CODEX_SANDBOX_ARGS[@]}"; do
            if [[ "$arg" == "-h" || "$arg" == "--help" ]]; then
                has_help_flag=true
                break
            fi
        done
    else
        for arg in "$@"; do
            if [[ "$arg" == "-h" || "$arg" == "--help" ]]; then
                has_help_flag=true
                break
            fi
        done
    fi

    if [[ "$has_help_flag" == true || "$subcommand" == "help" ]]; then
        case "$subcommand" in
            shell)  print_help_shell ;;
            up)     print_help_up ;;
            build)  print_help_build ;;
            tools)  print_help_tools ;;
            stop)   print_help_stop ;;
            down)   print_help_down ;;
            status) print_help_status ;;
            name)   print_help_name ;;
            codex)  print_help_codex ;;
            *)      print_help ;;
        esac
        exit 0
    fi

    if [[ "$subcommand" == "codex" ]]; then
        split_codex_args "$@"
        if [[ -z "${SANDBOX_CODEX_NO_TMUX:-}" ]]; then
            if ! ensure_tmux_available; then
                exit 1
            fi
            local session_name
            session_name="$(compute_codex_session_name)"
            local cmd=()
            cmd+=(env SANDBOX_CODEX_NO_TMUX=1 "$SCRIPT_PATH")
            cmd+=("${CODEX_SANDBOX_ARGS[@]}")
            if [[ "$CODEX_HAS_DOUBLE_DASH" == true ]]; then
                cmd+=(--)
                if [[ ${CODEX_ARGS+x} ]]; then
                    cmd+=("${CODEX_ARGS[@]}")
                fi
            fi
            if tmux has-session -t "=$session_name" 2>/dev/null; then
                if [[ -n "${TMUX:-}" ]]; then
                    tmux switch-client -t "=$session_name"
                else
                    tmux attach-session -t "=$session_name"
                fi
            else
                tmux new-session -d -s "$session_name" -c "$CALLER_PWD" "${cmd[@]}"
                if [[ -n "${TMUX:-}" ]]; then
                    tmux switch-client -t "=$session_name"
                else
                    tmux attach-session -t "=$session_name"
                fi
            fi
            exit 0
        fi

        parse_common_args "${CODEX_SANDBOX_ARGS[@]}"
        if ! determine_paths; then
            exit 1
        fi
        if [[ ${CODEX_ARGS+x} ]] && codex_args_have_conflicts; then
            echo "sandbox codex: 競合する引数が指定されたため中止しました。sandbox shell で codex を直接実行してください。" >&2
            exit 1
        fi
        if ! ensure_docker_available; then
            exit 1
        fi
        local container_name
        container_name="$(compute_container_name "$ABS_MOUNT_ROOT" "$ABS_WORKDIR")"
        local compose_project_name
        compose_project_name="$(compute_compose_project_name "$ABS_MOUNT_ROOT" "$ABS_WORKDIR")"
        local container_workdir
        container_workdir="$(compute_container_workdir "$ABS_MOUNT_ROOT" "$ABS_WORKDIR")"
        ensure_env_file
        ensure_agent_home_dirs
        if ! select_compose_cmd; then
            exit 1
        fi
        if ! compute_codex_mode "$ABS_MOUNT_ROOT" "$ABS_WORKDIR"; then
            exit 1
        fi
        if [[ -n "${CODEX_WARNING:-}" ]]; then
            echo "$CODEX_WARNING" >&2
        fi
        if [[ "${CODEX_MODE:-}" == "bootstrap" && -n "${CODEX_BOOTSTRAP_NOTICE:-}" ]]; then
            echo "$CODEX_BOOTSTRAP_NOTICE" >&2
        fi
        run_compose_up "$container_name" "$compose_project_name" "$ABS_MOUNT_ROOT"
        local codex_resume_args=("--cd" "$container_workdir")
        if [[ "${CODEX_MODE:-}" == "yolo" ]]; then
            codex_resume_args+=("--sandbox" "danger-full-access" "--ask-for-approval" "never")
        fi
        if [[ ${CODEX_ARGS+x} ]]; then
            codex_resume_args+=("${CODEX_ARGS[@]}")
        fi
        run_compose_exec_codex "$container_workdir" "$container_name" "$compose_project_name" "$ABS_MOUNT_ROOT" "${codex_resume_args[@]}"
        exit $?
    fi

    if [[ "$subcommand" == "name" ]]; then
        parse_common_args "$@"
        if ! determine_paths; then
            exit 1
        fi
        compute_container_name "$ABS_MOUNT_ROOT" "$ABS_WORKDIR"
        exit 0
    fi

    if [[ "$subcommand" == "up" ]]; then
        parse_common_args "$@"
        if ! determine_paths; then
            exit 1
        fi
        if ! ensure_docker_available; then
            exit 1
        fi
        local container_name
        container_name="$(compute_container_name "$ABS_MOUNT_ROOT" "$ABS_WORKDIR")"
        local compose_project_name
        compose_project_name="$(compute_compose_project_name "$ABS_MOUNT_ROOT" "$ABS_WORKDIR")"
        ensure_env_file
        ensure_agent_home_dirs
        if ! select_compose_cmd; then
            exit 1
        fi
        run_compose_up "$container_name" "$compose_project_name" "$ABS_MOUNT_ROOT"
        exit $?
    fi

    if [[ -z "$subcommand" ]]; then
        subcommand="shell"
    fi

    if [[ "$subcommand" == "shell" ]]; then
        parse_common_args "$@"
        if ! determine_paths; then
            exit 1
        fi
        if ! ensure_docker_available; then
            exit 1
        fi
        local container_name
        container_name="$(compute_container_name "$ABS_MOUNT_ROOT" "$ABS_WORKDIR")"
        local compose_project_name
        compose_project_name="$(compute_compose_project_name "$ABS_MOUNT_ROOT" "$ABS_WORKDIR")"
        local container_workdir
        container_workdir="$(compute_container_workdir "$ABS_MOUNT_ROOT" "$ABS_WORKDIR")"
        ensure_env_file
        ensure_agent_home_dirs
        if ! select_compose_cmd; then
            exit 1
        fi
        run_compose_up "$container_name" "$compose_project_name" "$ABS_MOUNT_ROOT"
        run_compose_exec "$container_workdir" "$container_name" "$compose_project_name" "$ABS_MOUNT_ROOT"
        exit $?
    fi

    if [[ "$subcommand" == "build" ]]; then
        parse_common_args "$@"
        local use_no_cache=true
        local arg
        for arg in "$@"; do
            case "$arg" in
                --cache)
                    use_no_cache=false
                    ;;
                --no-cache)
                    use_no_cache=true
                    ;;
            esac
        done
        if ! determine_paths; then
            exit 1
        fi
        if ! ensure_docker_available; then
            exit 1
        fi
        local container_name
        container_name="$(compute_container_name "$ABS_MOUNT_ROOT" "$ABS_WORKDIR")"
        local compose_project_name
        compose_project_name="$(compute_compose_project_name "$ABS_MOUNT_ROOT" "$ABS_WORKDIR")"
        ensure_env_file
        ensure_agent_home_dirs
        if ! select_compose_cmd; then
            exit 1
        fi
        if [[ "$use_no_cache" == true ]]; then
            run_compose_build "$container_name" "$compose_project_name" "$ABS_MOUNT_ROOT" --no-cache
        else
            run_compose_build "$container_name" "$compose_project_name" "$ABS_MOUNT_ROOT"
        fi
        exit $?
    fi

    if [[ "$subcommand" == "tools" ]]; then
        local tools_action
        tools_action="$(extract_tools_action "$@")"
        if [[ "$tools_action" != "update" ]]; then
            if [[ -z "$tools_action" ]]; then
                echo "Missing tools subcommand" >&2
            else
                echo "Unknown tools command: $tools_action" >&2
            fi
            echo "" >&2
            print_help_tools >&2
            exit 1
        fi

        parse_common_args "$@"
        if ! determine_paths; then
            exit 1
        fi
        if ! ensure_docker_available; then
            exit 1
        fi
        local container_name
        container_name="$(compute_container_name "$ABS_MOUNT_ROOT" "$ABS_WORKDIR")"
        local compose_project_name
        compose_project_name="$(compute_compose_project_name "$ABS_MOUNT_ROOT" "$ABS_WORKDIR")"
        local tools_container_name="${container_name}-tools-update"
        if ! acquire_tools_update_lock; then
            exit 1
        fi
        ensure_env_file
        ensure_agent_home_dirs
        if ! select_compose_cmd; then
            exit 1
        fi

        local tools_cmd
        tools_cmd=$'set -euo pipefail\n'\
$'mkdir -p /usr/local/share/npm-global /home/node/.npm/_cache\n'\
$'chown -R node:node /usr/local/share/npm-global /home/node/.npm\n'\
$'cd /opt/sandbox\n'\
$'gosu node npm run install-global\n'

        run_compose_run "$tools_container_name" "$compose_project_name" "$ABS_MOUNT_ROOT" \
            --rm --no-deps --user root -w /opt/sandbox --entrypoint /bin/bash agent-sandbox -lc "$tools_cmd"
        exit $?
    fi

    if [[ "$subcommand" == "stop" || "$subcommand" == "down" ]]; then
        parse_common_args "$@"
        if ! determine_paths; then
            exit 1
        fi
        if ! ensure_docker_available; then
            exit 1
        fi
        local container_name
        container_name="$(compute_container_name "$ABS_MOUNT_ROOT" "$ABS_WORKDIR")"
        local compose_project_name
        compose_project_name="$(compute_compose_project_name "$ABS_MOUNT_ROOT" "$ABS_WORKDIR")"
        if ! container_exists "$container_name"; then
            echo "No matching sandbox container: $container_name"
            exit 0
        fi
        ensure_env_file
        ensure_agent_home_dirs
        if ! select_compose_cmd; then
            exit 1
        fi
        if [[ "$subcommand" == "stop" ]]; then
            run_compose_stop "$container_name" "$compose_project_name" "$ABS_MOUNT_ROOT"
        else
            run_compose_down "$container_name" "$compose_project_name" "$ABS_MOUNT_ROOT"
        fi
        exit $?
    fi

    if [[ "$subcommand" == "status" ]]; then
        parse_common_args "$@"
        if ! determine_paths; then
            exit 1
        fi
        if ! ensure_docker_available; then
            exit 1
        fi
        local container_name
        container_name="$(compute_container_name "$ABS_MOUNT_ROOT" "$ABS_WORKDIR")"
        if ! get_container_status "$container_name"; then
            echo "container_name: $container_name"
            echo "status: not-found"
            echo "container_id: -"
            echo "mount_root: $ABS_MOUNT_ROOT"
            echo "workdir: $ABS_WORKDIR"
            echo "message: No matching sandbox container"
            exit 0
        fi
        local short_id="${CONTAINER_ID_FULL:0:12}"
        echo "container_name: $container_name"
        echo "status: $CONTAINER_STATUS"
        echo "container_id: $short_id"
        echo "mount_root: $ABS_MOUNT_ROOT"
        echo "workdir: $ABS_WORKDIR"
        exit 0
    fi

    echo "Not implemented: $subcommand" >&2
    exit 1
}

if [[ "${BASH_SOURCE[0]}" == "$0" ]]; then
    main "$@"
fi
